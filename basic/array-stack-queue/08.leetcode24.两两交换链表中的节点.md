## 题目
```
给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

 

示例 1：


输入：head = [1,2,3,4]
输出：[2,1,4,3]
示例 2：

输入：head = []
输出：[]
示例 3：

输入：head = [1]
输出：[1]
 

提示：

链表中节点的数目在范围 [0, 100] 内
0 <= Node.val <= 100

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```

### 思路

假设链表总长是偶数，那么递归函数执行到终止条件时，head 就等于 null。如果链表链表总长是偶数，那么递归函数执行到终止条件时，head.next 就等于 null。
递归函数内，我们要改变 1->2 的指向，将其改为 2->1。
那后面的节点怎么办呢？不用担心，这是由下一层递归函数来解决。
下一层递归函数返回后的节点是 4，就是4->3->...这样的了，也就是后面的节点都已经串联好了。
所以我们只需要将 1 节点指向 4 就可以了！

### 代码

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        //递归的终止条件
        if (head == null || head.next == null) {
            return head;
        }
        //假设链表是 1->2->3->4
        //这句就先保存节点2
        //留下递归前的‘练习方式’
        ListNode tmp = head.next;
        //继续递归，处理节点3->4
        //当递归结束返回后，就变成了4->3
        //于是head节点就指向了4，变成1->4->3
        head.next = swapPairs(tmp.next);
        //将2节点指向1
        tmp.next = head;
        return tmp;
    }
}
```
### 复杂度分析

- 时间复杂度: O(N)，其中N为链表的长度。
- 空间复杂度: O(N)。
